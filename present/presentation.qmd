---
title: "A new way of viewing maps - hexmap"
author: "Ziyao(Billy) Wang"
date: "`r Sys.Date()`"
format: 
  revealjs:
    logo: images/monash-logo.png
    slide-number: true
    multiplex: true
    show-slide-number: all
    width: 1280
    height: 720
    controls: true
    css: assets/custom.css
    transition: slide
execute:
  echo: true
  eval: false
title-slide-attributes: 
  data-background-image: images/bg-pic.gif
  data-background-opacity: "0.6"
editor: visual
---

## Motivation {.smaller .scrollable}

::: incremental
-   Map sometimes can convey ***misleading information or conclusion***.

-   **Example**

-   [2022 AU Election Data](https://results.aec.gov.au/27966/Website/HouseDownloadsMenu-27966-Csv.htm)

    ![](images/choropleth.png){alt="2022 AU Election Data" fig-align="center" width="437"}

-   Who is winning the election?
:::

------------------------------------------------------------------------

## An alternative way. {.smaller .scrollable}

![](images/hexmap.png){fig-align="center"}

::: incremental
-   Yet, this is [**manually made**]{.underline}.
:::

------------------------------------------------------------------------

### Other Examples

::: columns
::: {.column width="50%"}
![](images/paste-C0FB8E3F.png){fig-align="center"}
:::

::: {.column width="50%"}
![](images/paste-8924B4DD.png){fig-align="center"}
:::
:::

## Purpose of [hexmap](https://github.com/numbats/hexmap) package:

::: incremental
-   To automate the conversion of **spatial polygons into hexagonal grids**.

-   This conversion allows users to better [visualize statistical values associated with each geographic region]{.underline}.
:::

::: incremental
-   Sample data - 2022 Australian Election Data from [AEC](https://results.aec.gov.au/27966/Website/HouseDownloadsMenu-27966-Csv.htm).
:::

------------------------------------------------------------------------

### **How does this [`hexmap`](https://github.com/numbats/hexmap) work?**

::: incremental
![](images/dino-wonder.gif){fig-align="center" width="358"}
:::

[Credit](https://tenor.com/view/dino-wonder-think-hmm-gif-16104056)

## [hexmap](https://github.com/numbats/hexmap) Tour {.smaller}

### General workflow

-   Note the package is [still under development]{.underline} \[**On progress\]**

![](images/workflow.png){fig-align="center"}

------------------------------------------------------------------------

## Step 1 - Refine the input data {.smaller .scrollable}

1.  Input Data Type - A [Simple Features](https://r-spatial.github.io/sf/index.html) (sf) object

2.  Reasons for refinement:

    This will **speeds up** the computation of later processes.

    It can [**reduce the input data size**]{.underline} significantly.

-   Ways to refine:

::: columns
::: {.column width="50%"}
Using `st_simplify()` from [`sf`](https://github.com/r-spatial/sf)

```{r}
# allow for simplifying regions based on a distance argument, 
## but large distances can completely remove polygons.
inputdata %>% sf::st_simplify(dTolerance = 3000)
## dTolerance = a numeric tolerance parameter to smooth the edge
```
:::

::: {.column width="50%"}
Functions from [`sfheaders`](https://github.com/dcooley/sfheaders) and [`rmapshaper`](https://github.com/ateucher/rmapshaper)

```{r}
inputdata %>%
 # simplifying regions to a proportion of their original vertices
  sfheaders::sf_remove_holes() %>%
  # To remove holes from polygons and multipolygons.
 ## In case, there are some great lakes / not land areas.
  rmapshaper::ms_simplify(keep = 0.0001, keep_shapes = TRUE)
 # keep: Proportion of points to retain;
 # keep_shapes: Prevent small polygon features 
 ## from disappearing at high simplification
```
:::
:::

::: incremental
-   Example data size reduction- Sample data `abs_ced` from [`ozmaps`](https://github.com/mdsumner/ozmaps)

    ![](images/paste-0FE0B280.png){fig-align="center"}

-   Functions from [`cartogram`](https://github.com/sjewo/cartogram) to distort the original data according to a specific variable set by users.

    -   See example illustration on **Appendix** ("cartogram distortion")

        ```{r}
            cartogram::cartogram_cont("inputdata",
              weight = "weight",
              itermax = 20,
              prepare = "adjust")
            # weight: weighting variable in data
            # itermax: Number of iterations for distortion
            # prepare: Methods to help
        ```
:::

------------------------------------------------------------------------

## Step 2 - Determine the number of hexagons {.smaller .scrollable}

::: panel-tabset
## Purpose&Procedure

See additional explanations on **Appendix** ("Step 2 workflow cont.")

::: columns
::: {.column width="50%"}
### **Knowing**:

1.  Number of hexagons for the entire map (both land and others)

2.  Number of hexagons for the land area

3.  Take the intersection, to obtain the number of hexagons needed for statistical values

![](images/paste-9FC7ACA1.png){fig-align="center"}
:::

::: {.column width="50%"}
::: incremental
-   Total number of hexagons for the entire map depends on: **`Hexagon width`**

    ![](images/paste-7757D6A1.png){fig-align="center"}
:::
:::
:::

## Example Illustration

### Observe **"cell size" (i.e. [width]{.underline}**)

-   **Notes**: The number of hexagons in [**odd and even**]{.underline} rows are different.

    ::: columns
    ::: {.column width="50%"}
    ![](images/paste-0793C53E.png)
    :::

    ::: {.column width="50%"}
    ![](images/paste-BFF8301B.png)
    :::
    :::
:::

------------------------------------------------------------------------

## [`hex_grid`](https://github.com/numbats/hexmap/blob/master/R/map-tile.R) function to calculate desired number of hexagons {.smaller .scrollable}

```{r}
hexmap::hex_grid(object, n_tiles = 100)
# object: input data (i.e. sf object)
# n_tiles: wanted number of hexagons
```

::: columns
::: {.column width="50%"}
-   **normal choropleth**

![](images/step2-choro.png){fig-align="center"}
:::

::: {.column width="50%"}
-   **distorted cartogram**

![](images/step2-distort.png){fig-align="center"}
:::
:::

::: incremental
-   See reproducible codes for above examples in **Appendix (**"Step 2 example-code")
:::

## Step 3 - Allocate statistical values on hexagons {.smaller .scrollable}

::: incremental
-   Assigning the statistical information (can be set by the users), using an algorithm.

-   Sample - [AEC](https://results.aec.gov.au/27966/Website/HouseDownloadsMenu-27966-Csv.htm) data

    -   statistical information: (151) electoral;

    -   Algorithm: "[Hungarian Algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm)" from [`geogrid`](https://github.com/jbaileyh/geogrid)

    -   See application example of [`geogrid`](https://github.com/jbaileyh/geogrid) functions on **Appendix** ("geogrid functions: ...")

-   ![](images/step3-workflow.png){alt="Workflow"}
:::

------------------------------------------------------------------------

## [`tile_allocate`](https://github.com/numbats/hexmap/blob/master/R/map-allocate.R) function to allocate statistical information on hexagons {.smaller .scrollable}

```{r}
hexmap::tile_allocate(object, tile)
# object: input data (i.e. sf object)
# tile: output from `hex_grid` function (i.e. a sfc object)
```

::: columns
::: {.column width="50%"}
::: incremental
-   Allocation of statistical values on a **normal choropleth**

    ![](images/step3-choro.png){width="567" height="362"}
:::
:::

::: {.column width="50%"}
::: incremental
-   Allocation of statistical values on a **distorted cartogram**

    ![](images/step3-distort.png)
:::
:::
:::

::: incremental
-   See reproducible codes on **Appendix** ("Step 3 example codes")
    -   Plus, some tests on using mixture of grids.
:::

------------------------------------------------------------------------

## Future improvements {.smaller .scrollable}

::: incremental
For step 1 - Refining the input data
:::

::: incremental
-   New functions to [distort or refine]{.underline} the input data (i.e. a better data pre-processing).
:::

::: incremental
For step 2 - Constructing a hexagonal grid (provided with wanted number of hexagons)
:::

::: incremental
-   Improve the "Approximation" for the number of hexagons, calculating the wanted number of hexagon exactly.
:::

For step 3 - Assigning the statistical information to geographic regions

::: incremental
-   Try different distance (methods) to produce a better distance matrix \[[**Currently testing**]{.underline}\]
-   Or, testing alternative algorithms such as the "[Genetic-algorithm](https://medium.com/sandstreamdev/the-genetic-algorithm-in-solving-the-quadratic-assignment-problem-9bde6ead47ab)", R packages like "[GA](http://luca-scr.github.io/GA/index.html)" .
:::

------------------------------------------------------------------------

## Discussion

**Welcome to share your thoughts!**

::: incremental
![](images/qa.gif){fig-align="center"}
:::

------------------------------------------------------------------------

## Package Installation {.smaller .scrollable}

::: incremental
-   View on [Github](https://github.com/numbats/hexmap)

    ```{r installation}
    install.packages("remotes")
    remotes::install_github("numbats/hexmap")
    ```
:::

::: incremental
**Acknowledgement**

-   The slides are made using [Quarto](https://quarto.org/) with [Emi Tanaka's](https://github.com/emitanaka/talks) CSS design.

-   Great thanks to [**Mitchell O'Hara-Wild**](https://github.com/mitchelloharawild) & [**Emi Tanaka**](https://github.com/emitanaka)

    ![](images/applause.gif){fig-align="\"center"}
:::

## Appendix {.smaller .scrollable}

### cartogram distortion

-   Distortion example (by `cartogram`)

![](images/paste-FFA7FEBC.png){fig-align="center" width="587"}

```{r}
cartogram::cartogram_cont("input data", weight = "weight variable", itermax = 15)
# weight: Name of the weighting variable in x 
# itermax: Maximum iterations for the cartogram transformation
```

## [geogrid](https://github.com/jbaileyh/geogrid) functions: allocation of statistic values on hexagons {.smaller .scrollable}

::: columns
::: {.column width="50%"}
-   Using a normal choropleth

    <div>

    ![](images/choropleth-geogrid.png){fig-align="center" width="524"}

    </div>

```{r}
library(tmap)
library(geogrid)
library(cartogram)
library(maptools)

data_grid <-
  calculate_grid(shape = "input data",
                 grid_type = "hexagonal",
                 seed = 5) 
# seed: Number of iterations for the grid calculation

result_hex <- assign_polygons("input data", data_grid)

# plot the hexmap
tm_shape(result_hex) + 
  tm_polygons("group variable", palette = "viridis") +
  tm_text("group variable")
```
:::

::: {.column width="50%"}
-   Using a distorted cartogram

    ![](images/distorted-geogrid.png){fig-align="center" width="529"}

    ```{r}
    library(tmap)
    library(geogrid)
    library(cartogram)
    library(maptools)

    cartogram::cartogram_cont("input data", "weighting variable", 15)

    data_grid <-
      calculate_grid(shape = "input data",
                     grid_type = "hexagonal",
                     seed = 5) 
    # seed: Number of iterations for the grid calculation

    result_hex <- assign_polygons("input data", data_grid)

    # plot the hexmap
    tm_shape(result_hex) + 
      tm_polygons("weighting variable", palette = "viridis") +
      tm_text("weighting variable")
    ```
:::
:::

------------------------------------------------------------------------

## Step 2 workflow cont. {.smaller .scrollable}

To find a proper width for a hexagon

::: panel-tabset
## Known Parameters

![](images/paste-1EB42C99.png){fig-align="center"}

## Unknown Parameters

-   **The [width]{.underline} and number of hexagons**

-   A possible solution (example in [**an unit square hexagon**]{.underline}):

::: columns
::: {.column width="50%"}
-   $h = 2 w / \sqrt{3}$ and $b = w / \sqrt{3}$

![](images/paste-E6B9C3AF.png){fig-align="center"}
:::

::: {.column width="50%"}
::: incremental
-   **`n_t`** = total number of hexagons; **`n_land`** = desired number of hexagons

    ![](images/paste-180AF7C6.png){fig-align="center" width="402"}
:::
:::
:::

::: incremental
-   Detail explanation \[[**Help Page**](https://numbats.github.io/hexmap/articles/calculate-grid.html)\]
-   Function ([`map_tile`](https://github.com/numbats/hexmap/blob/master/R/map-tile.R)) applies [*an approximation*]{.underline} to obtain the [**wanted**]{.underline} number of hexagons. (Credit to [**Mitchell O'Hara-Wild**](https://github.com/mitchelloharawild)**)**
:::
:::

## Step 2 example-code {.smaller .scrollable}

::: columns
::: {.column width="50%"}
-   Normal Choropleth

    ```{r}
    library(hexmap)
    library(sf)

    # Using a normal choropleth
    grid1 <-  hexmap::hex_grid(object = "input data", 
                               n_tiles = 151) # n: number of wanted hexagons

    # Plot the geographic map with overlaying hexagons
    ggplot() +
      geom_sf(data = "input data") +
      geom_sf(data = grid1, fill = "steelblue", alpha = 0.2)+
      theme_void()
    ```
:::

::: {.column width="50%"}
-   cartogram distorted

    ```{r}
    library(hexmap)
    library(sf)

    `distorted input data` <- cartogram::cartogram_cont("input data", 
                                                      weight = "variable", 
                                                      itermax = 15)
    # With cartogram distortion
    grid2 <- hexmap::hex_grid(object = "distorted input data", 
                              n_tiles = 151) # n: number of wanted hexagons

    # Plot the geographic map with overlaying hexagons
    ggplot() +
      geom_sf(data = `distorted input data`) +
      geom_sf(data = grid2, fill = "pink", alpha = 0.2)+
      theme_void()
    ```
:::
:::

## Step 3 example codes {.smaller .scrollable}

```{r}
library(hexmap)
library(sf)
library(dplyr)
library(ggplot2)

# Using a normal choropleth
grid1 <-  hexmap::hex_grid(object = "input data", 
                               n_tiles = 151) # n: number of wanted hexagons

# With cartogram distortion
grid2 <- hexmap::hex_grid(object = "distorted input data", 
                              n_tiles = 151) # n: number of wanted hexagons

# For a normal choropleth
grid3 <- hexmap::tile_allocate(object = "input data", tile = grid1)
# For a cartogram distortion
grid4 <- hexmap::tile_allocate(object = "distorted input data", tile = grid2)

ggplot2::ggplot()+
  geom_sf(data = "input data")+
  geom_sf(data = grid3, aes(fill = "group variable", alpha = 0.2))+
  theme(legend.text=element_text(size=30))+
  guides(fill = guide_legend(override.aes = list(size = 28)))+
  theme_void()

ggplot2::ggplot()+
  geom_sf(data = "distorted input data")+
  geom_sf(data = grid4, aes(fill = "group variable", alpha = 0.2))+
  theme(legend.text=element_text(size=30))+
  guides(fill = guide_legend(override.aes = list(size = 28)))+
  theme_void()
```

::: panel-tabset
## Mixture one

![](images/step3-mix1.png)

```{r}
library(hexmap)
library(sf)
library(dplyr)
library(ggplot2)

# mixing the choropleth with distorted grid for allocation
grid_mix1 <- hexmap::tile_allocate(object = "input data", tile = grid2)

# plot 1st mixture ("grid_mix1")
ggplot2::ggplot()+
  geom_sf(data = "distorted input data")+
  geom_sf(data = grid_mix1, aes(fill = "group variable", alpha = 0.2))+
  theme(legend.text=element_text(size=30))+
  guides(fill = guide_legend(override.aes = list(size = 28)))+
  theme_void()
```

## Mixture two

![](images/step3-mix2.png)

```{r}
library(hexmap)
library(sf)
library(dplyr)
library(ggplot2)

# mixing the distorted cartogram with the normal choropleth grid for allocation
grid_mix2 <- hexmap::tile_allocate(object = "distorted input data", tile = grid1)


# plot 2nd mixture ("grid_mix2")
ggplot2::ggplot()+
  geom_sf(data = "input data")+
  geom_sf(data = grid_mix2, aes(fill = "group variable", alpha = 0.2))+
  theme(legend.text=element_text(size=30))+
  guides(fill = guide_legend(override.aes = list(size = 28)))+
  theme_void()
```
:::

::: incremental
-   Most likely, the assignment of hexagons will be measured by some sorts of [**distance matrix**]{.underline} to find the "best" allocation.
    -   (Yet, this may result in a "*NP hard problem*" for optimization).
:::
