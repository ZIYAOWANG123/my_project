---
title: "A new way of viewing maps - Hexmap"
author: "Ziyao(Billy) Wang"
date: "`r Sys.Date()`"
format: 
  revealjs:
    logo: images/monash-logo.png
    slide-number: true
    multiplex: true
    show-slide-number: all
    width: 1280
    height: 720
    controls: true
    css: assets/custom.css
    transition: slide
execute:
  echo: true
  eval: false
title-slide-attributes: 
  data-background-image: images/bg-pic.gif
  data-background-opacity: "0.6"
editor: visual
---

## Introduction {.smaller}

![](images/auselection-2022.gif){fig-align="center" width="422" height="407"}

-   Code for installing the package.

```{r installation}
install.packages("remotes")
remotes::install_github("numbats/hexmap")
```

------------------------------------------------------------------------

## Purpose of [`Hexmap`](https://github.com/numbats/hexmap) package:

::: incremental
-   To automate the conversion of **spatial polygons into hexagonal grids**.

-   This conversion allows users to better [visualize statistical values associated with each geographic region]{.underline}.
:::

::: incremental
-   Sample data - 2022 Australian Election Data from [AEC](https://results.aec.gov.au/27966/Website/HouseDownloadsMenu-27966-Csv.htm).
:::

------------------------------------------------------------------------

## Motivation {.smaller .scrollable}

::: incremental
-   Map sometimes can convey ***misleading information or conclusion***.

-   **Example**

    ::: incremental
    -   Who is winning the election?
    :::
:::

![2022 AU Election Data](images/paste-EB66B39E.png){alt="2022 AU Election Data" fig-align="center" width="437"}

------------------------------------------------------------------------

## An alternative way. {.smaller}

::: incremental
-   Red - **ALP**; Blue - **LNP**

::: incremental
![2022 AU Election - Hexgrid](images/paste-592B5C3C.png){alt="2022 AU Election - Hexgrid" fig-align="center" width="382"}
:::

-   Yet, this is [**manually made**]{.underline}.

-   **Notes**: although the illustration shows a separation of each state, yet they are [*connected geographically*]{.underline}.
:::

------------------------------------------------------------------------

### Other Examples

::: columns
::: {.column width="50%"}
![](images/paste-C0FB8E3F.png){fig-align="center"}
:::

::: {.column width="50%"}
![](images/paste-8924B4DD.png){fig-align="center"}
:::
:::

------------------------------------------------------------------------

### **How does this `Hexmap` work?**

![](images/dino-wonder.gif){fig-align="center" width="272"}

[Credit](https://tenor.com/view/dino-wonder-think-hmm-gif-16104056)

## Hexmap Tour {.smaller}

### General workflow

-   Note the package is [still under development]{.underline} \[**On progress\]**

![](images/workflow.png){fig-align="center"}

------------------------------------------------------------------------

## Step 1 - Refining the input data {.smaller .scrollable}

1.  Input Data Type - A [Simple Features](https://r-spatial.github.io/sf/index.html) (sf) object

2.  Reasons for refinement:

    This will **speeds up** the computation of later processes.

    It can [**reduce the input data size**]{.underline} significantly.

3.  Ways to refine:

    1.  Using `st_simplify()` from [`sf`](https://github.com/r-spatial/sf)

        ```{r}
        inputdata %>% sf::st_simplify(dTolerance = 3000)
        # dTolerance = a numeric tolerance parameter to smooth the edge
        ```

    2.  Functions from [`sfheaders`](https://github.com/dcooley/sfheaders) and [`rmapshaper`](https://github.com/ateucher/rmapshaper)

        ```{r}
        inputdata %>%
          # To remove holes from polygons and multipolygons.
          ## In case, there are some great lakes / not land areas.
          sfheaders::sf_remove_holes() %>%
          rmapshaper::ms_simplify(keep = 0.0001, keep_shapes = TRUE)
          # keep: Proportion of points to retain;
          # keep_shapes: Prevent small polygon features from disappearing at high simplification
        ```

    3.  Functions from [`Cartogram`](https://github.com/sjewo/cartogram) to distort the original data according to a specific variable set by users.

        ```{r}
        cartogram::cartogram_cont(au,
                                  weight = "weight",
                                  itermax = 20,
                                  prepare = "adjust")
        # weight: weighting variable in data
        # itermax: Number of iterations for distortion
        # prepare: Methods to help
        ```

------------------------------------------------------------------------

-   Example data size reduction- Sample data `abs_ced` from [`ozmaps`](https://github.com/mdsumner/ozmaps)

![](images/paste-0FE0B280.png){fig-align="center"}

```{r}
library(sf)
library(hexmap)
library(ozmaps)
library(dplyr)

sf1 <- abs_ced %>% 
  st_simplify(dTolerance = 3000)
  
ms1 <- abs_ced %>%
  sfheaders::sf_remove_holes() %>%
  rmapshaper::ms_simplify(keep = 0.0001, keep_shapes = TRUE)

object.size(abs_ced)
object.size(sf1)
object.size(ms1)
```

------------------------------------------------------------------------

-   Distortion example (by `cartogram`)

![](images/paste-FFA7FEBC.png){fig-align="center" width="587"}

------------------------------------------------------------------------

## Step 2 - Determine the number of hexagons {.smaller .scrollable}

::: columns
::: {.column width="50%"}
-   **Knowing**:

    1.  Number of hexagons for the entire map (both land and others)

    2.  Number of hexagons for the land area

    3.  Take the intersection, to obtain the number of hexagons needed for statistical values

![](images/paste-9FC7ACA1.png){fig-align="center"}
:::

::: {.column width="50%"}
-   Total number of hexagons for the entire map depends on: **`Hexagon width`**

![](images/paste-7757D6A1.png){fig-align="center"}
:::
:::

-   Example Illustration ([**"cell size" = width**]{.underline})

-   **Notes**: The number of hexagons in [**odd and even**]{.underline} rows are different.

    ::: columns
    ::: {.column width="50%"}
    ![](images/paste-0793C53E.png)
    :::

    ::: {.column width="50%"}
    ![](images/paste-BFF8301B.png)
    :::
    :::

------------------------------------------------------------------------

## To find a proper width for a hexagon {.smaller .scrollable}

-   Known parameters:

![](images/paste-1EB42C99.png){fig-align="center"}

-   **Unknown: the [width]{.underline} of a hexagon**

-   A possible solution (example in [**an unit square hexagon**]{.underline}):

::: columns
::: {.column width="50%"}
-   $h = 2 w / \sqrt{3}$ and $b = w / \sqrt{3}$

![](images/paste-E6B9C3AF.png){fig-align="center"}
:::

::: {.column width="50%"}
-   **`n_t`** = total number of hexagons; **`n_land`** = desired number of hexagons

![](images/paste-180AF7C6.png){fig-align="center" width="402"}
:::
:::

::: incremental
-   Detail explanation \[[**Help Page**](https://numbats.github.io/hexmap/articles/calculate-grid.html)\]
-   Function ([`map_tile`](https://github.com/numbats/hexmap/blob/master/R/map-tile.R)) applies [*an approximation*]{.underline} to obtain the [**wanted**]{.underline} number of hexagons. (Credit to [**Mitchell O'Hara-Wild**](https://github.com/mitchelloharawild)**)**
:::

------------------------------------------------------------------------

## Step 3 - Allocating statistical information onto hexagons {.smaller}

::: incremental
-   Assigning the statistical information (can be set by the users), using an algorithm.
-   Example
    -   statistical information: winning party for each electoral;

    -   Algorithm: "[Hungarian Algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm)" from [`geogrid`](https://github.com/jbaileyh/geogrid)
:::

------------------------------------------------------------------------

-   Distance matrix illustration

asdfasdf

------------------------------------------------------------------------

-   Examples illustrates using `calculate_grid & assign_polygons` functions from [`geogrid`](https://github.com/jbaileyh/geogrid)

![](images/paste-91C64537.png){fig-align="center" width="524"}

```{r}
data_grid <-
  calculate_grid(shape = "input data",
                 grid_type = "hexagonal",
                 seed = 5) # Number of iterations for the grid calculation

assign_polygons("input data", data_grid)
```

------------------------------------------------------------------------

## Future developments {.smaller .scrollable}

::: incremental
For step 1 - Refining the input data
:::

::: incremental
-   Instead of using `cartogram` package, writing a new function to [distort or refine]{.underline} the input data (i.e. a better data pre-processing).
:::

::: incremental
For step 2 - Constructing a hexagonal grid (according users customize the number)
:::

::: incremental
-   Improve the "Approximation" for the number of hexagons, calculating the wanted number of hexagon exactly.
:::

For step 3 - Assigning the statistical information to geographic regions

::: incremental
-   Searching for an alternative algorithm which is more effective and efficient if possible such as the "[Genetic-algorithm](https://medium.com/sandstreamdev/the-genetic-algorithm-in-solving-the-quadratic-assignment-problem-9bde6ead47ab)" and "[GA](http://luca-scr.github.io/GA/index.html)" R package.
-   Or, improving the "Hungarian Algorithm" to enhance allocation accuracy and process.
-   Most likely, the assignment of hexagons will be measured by some sorts of [**distance matrix**]{.underline} to find the "best" allocation.
    -   (Yet, this may result in a "*NP hard problem*" for optimization).
:::

------------------------------------------------------------------------

## Discussion

**Welcome to share your thoughts or suggestions!**

![](images/qa.gif){fig-align="center"}

## Reference {.smaller .scrollable}

-   The slides are made using [Quarto](https://quarto.org/) with [Emi Tanaka's](https://github.com/emitanaka/talks) CSS design.
-   
