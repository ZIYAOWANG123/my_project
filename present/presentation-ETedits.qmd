---
title: "Towards automatic construction of<br> [hex maps]{style='color:#006DAE;'}"
author: "Ziyao (Billy) Wang"
format: 
  revealjs:
    incremental: true
---



## Motivation

Australian Federal Election 2022

```{r setup, include = FALSE}
knitr::opts_chunk$set(eval = FALSE, 
                      echo = TRUE, 
                      warning = FALSE)
```
<center>
<img src="ozhexmap.gif">
</center>


## Aim

- To automate the conversion of **spatial polygons into hexagonal grids**

### Motivation

-   Map illustration takes a vital role in exploratory data analysis (EDA).

-   **However**, it sometimes can convey ***misleading information or conclusion***.


**Example**

::: incremental
-   Who is winning the election?
-   LNP looks dominating? It must be the winner, right?
-   In fact, **ALP** was the winner in this (2022) election.
:::

![2022 AU Election Data](images/paste-EB66B39E.png){fig-align="center" width="437"}

-   Now, let's use another way to view the election result.

    ::: incremental
    -   Different colours represent the statistical values (i.e. the winning party).
        -   Red - **ALP**; Blue - **LNP**

            ![2022 AU Election - Hexgrid](images/paste-592B5C3C.png){fig-align="center" width="382"}
    :::

------------------------------------------------------------------------

`Hexmap` is here to resolve this issue:

-   By reshaping the geographical area into multiple hexagons and allocating the statistics properly.

-   Example from [ABC](https://www.abc.net.au/news/2022-05-20/federal-election-map-lying/101076016) News release:

![1st - Spread hex_grid onto regions](images/mot_2.png){fig-align="center" width="328"}

------------------------------------------------------------------------

![2nd - Group statistical values by states](images/mot_3.png){fig-align="center" width="306" height="310"}

![Example of information in state level](images/mot_4.png){fig-align="center" width="347" height="248"}

------------------------------------------------------------------------

The final Hexmap by overlaying the statistical information and combing each state together.

::: incremental
-   **Notes**: although the illustration shows a separation of each state, yet in `Hexmap` they are [*connected geographic regions*]{.underline}.

    ![](images/paste-592B5C3C.png){fig-align="center" width="382"}
:::

------------------------------------------------------------------------

Another example in `Hexmap` by [**Emi Tanaka**](https://github.com/emitanaka).

![](images/paste-43C26528.png){fig-align="center" width="69%"}

------------------------------------------------------------------------

**How does this `Hexmap` work?**

![](images/dino-wonder.gif){fig-align="center" width="272"}

[Credit](https://tenor.com/view/dino-wonder-think-hmm-gif-16104056)

## Hexmap Tour

### General workflow

-   Note the package is [still under development]{.underline} \[**On progress\]**

#### Step 1 - Refining the input data

::: incremental
-   Using the [`Cartogram`](https://github.com/sjewo/cartogram) package function to distort the original data according to a specific variable set by users.

-   To improve the accuracy and computation efficiency for later calculation.

-   For example, in AEC example, using the number of electoral - equal weight for each one.
:::

------------------------------------------------------------------------

-   **Example illustration - Cartogram distortion**

    ```{r}
    cartogram::cartogram_cont(au, weight = "weight", itermax = 20, prepare = "adjust")
    # weight: weighting variable in data
    # itermax: Number of iterations for distortion
    # prepare: Methods to help convergence of hte distortion 
    ```

![](images/paste-FFA7FEBC.png){fig-align="center" width="587"}

------------------------------------------------------------------------

#### Step 2 - Calculating the number of hexagons for each region

::: incremental
-   Using function ([`map_tile`](https://github.com/numbats/hexmap/blob/master/R/map-tile.R)) to obtain the [**proper/wanted**]{.underline} number of hexagons for the entire geographic region.
-   Credit to [**Mitchell O'Hara-Wild**](https://github.com/mitchelloharawild)
:::

------------------------------------------------------------------------

-   Math procedure explanation \[[**Help Page**](https://numbats.github.io/hexmap/articles/calculate-grid.html)\]

```{r}
hex_grid <- function(object, n_tiles = 100) {
  # Get map data
  map_width <- diff(unname(st_bbox(object))[c(1,3)])
  map_height <- diff(unname(st_bbox(object))[c(2,4)])
  map_area <- st_area(st_as_sfc(st_bbox(object)))
  map_ratio <- map_width / map_height

  # Compute ratio of land to map
  land_area <- sum(st_area(object))
  land_ratio <- as.numeric(land_area / map_area)

  # Number of hexagons to tile map such that ~n_tiles hexagons overlap land
  map_hex <- n_tiles / land_ratio

  # Size of hexagons
  hex_height <- map_height / sqrt(map_hex/map_ratio)
  hex_width <- hex_height / (1.5/sqrt(3))

  # Create grid
  hex_grid <- st_make_grid(object, cellsize = hex_width, square = FALSE)
  hex_grid <- st_sf(hex_grid, hex_id = seq_along(hex_grid))

  # Choose most overlapping n_tiles hexagons for map tiling
  hex_best <- st_intersection(hex_grid, object) %>%
    dplyr::group_by(!!sym("hex_id")) %>%
    dplyr::summarise(area = sum(st_area(hex_grid))) %>%
    dplyr::top_n(n_tiles, wt = !!sym("area")) %>%
    dplyr::pull(!!sym("hex_id"))

  # Return the best hexagons
  sf::st_geometry(hex_grid)[hex_grid$hex_id %in% hex_best]
}
```

------------------------------------------------------------------------

-   **Example illustration - `map_tile`**

a

------------------------------------------------------------------------

#### Step 3 - Allocating statistical information onto hexagons

::: incremental
-   Assigning the statistical information (can be set by the users), using an algorithm.
-   Example
    -   statistical information: winning party for each electoral;

    -   Algorithm: "[Hungarian Algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm)" from [`geogrid`](https://github.com/jbaileyh/geogrid)
:::

------------------------------------------------------------------------

-   Explanation of the `Hungarian Algorithm`

asdfasdf

------------------------------------------------------------------------

-   Distance matrix illustration

asdfasdf

------------------------------------------------------------------------

-   Examples illustrates using `calculate_grid & assign_polygons` functions from [`geogrid`](https://github.com/jbaileyh/geogrid)

![](images/paste-91C64537.png){fig-align="center" width="524"}

```{r}
data_grid <-
  calculate_grid(shape = "input data",
                 grid_type = "hexagonal",
                 seed = 5) # Number of iterations for the grid calculation

assign_polygons("input data", data_grid)
```

------------------------------------------------------------------------

### Future developments

::: incremental
1.  For step 1 - Refining the input data
:::

::: incremental
-   Instead of using `cartogram` package, writing a new function to [distort or refine]{.underline} the input data (i.e. a better data pre-processing).
:::

::: incremental
2.  For step 2 - Constructing a hexagonal grid (according users customize the number)
:::

::: incremental
-   Improve the "Approximation" for the number of hexagons, calculating the wanted number of hexagon exactly.
:::

------------------------------------------------------------------------

3.  For step 3 - Assigning the statistical information to geographic regions

::: incremental
-   Searching for an alternative algorithm which is more effective and efficient if possible such as the "[Genetic-algorithm](https://medium.com/sandstreamdev/the-genetic-algorithm-in-solving-the-quadratic-assignment-problem-9bde6ead47ab)" and "[GA](http://luca-scr.github.io/GA/index.html)" R package.
-   Or, improving the "Hungarian Algorithm" to enhance allocation accuracy and process.
-   Most likely, the assignment of hexagons will be measured by some sorts of [**distance matrix**]{.underline} to find the "best" allocation.
    -   (Yet, this may result in a "*NP hard problem*" for optimization).
:::

## Installation

```{r installation}
install.packages("remotes") # or
remotes::install_github("numbats/hexmap")
```

### Discussion

**Welcome to share your thoughts or suggestions!**

## Reference
